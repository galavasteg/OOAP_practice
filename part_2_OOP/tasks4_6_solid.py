"""
----------------------- TASK 4 -----------------------

Приведите пример иерархии классов (словесное описание), где применяется принцип
Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а
другие закрытыми.

Дядюшка Боб зафиксировал The Open Closed Principle (OCP) слова Бертрана Мейера:
"Программные сущности должны быть открыты для расширения и закрыты для изменения."
Далее продолжает: "... должна иметься возможность расширять поведение
программных сущностей без их изменения."

Продолжу мысль "велосипедной" иерархией из предущих заданий:
https://github.com/galavasteg/OOAP_practice/blob/master/part_2_OOP/iInheritance_composition_polymorphism.py

Класс "Bicycle" закрыт: он описывает базовую модель типа (наличие колес,
руля, способность перемещаться, поворачивать и т.д.). В то время как класс
"ElectricRoadBicycle" - открытый - расширяет "Bicycle" новыми возможностями
(например, способность перемещаться с помощью энергии двигателя), опираясь
на уже заложенную в родителя базовую модель, НЕ изменяя ее реализацию.


----------------------- TASK 5 -----------------------

Какие из пяти принципов повторного использования модуля поддерживаются в
используемом вами языке программирования (в дополнение к классам как базовой
синтаксической единице)?

Python: 1, 2, 3, 5

1. Новый модуль может задавать некоторый базовый тип, который потенциально
   должен допускать параметризацию другими типами (обобщённые типы, типы-генерики);

В Python - язык с динамической типизацией - параметризация типом не требуется:
в нем поддерживается работа со списками объектов разных типов. Также,
в его стандартной библиотеке имеются инструменты позволяющие создавать generics.
Однако, для проверки типизации в момент исполнения кода необходимы дополнительные
действия со стороны программиста и/или использование сторонних библиотек.

2. Новый модуль может объединять несколько функций, которые активно обращаются
   друг к другу;

С помощью python-модуля: каждой функции в нем известно о существовании остальных.
С помощью методов класса: методы будут иметь доступ к другим методам этого класса
(через экземпляр или через сам класс).

3. Новый модуль может входить в семейство модулей, ориентированных на решение
   некоторой общей задачи, которую не удаётся решить с помощью одного модуля;

Python-модуль(и) как раз может являться тамим семейством модулей (классов).

4. Новый модуль может предлагать конкретную реализацию родительского модуля,
   которая должна выбираться динамически (полиморфно) -- например, реализация
   обобщённого типа для конкретного типа-параметра;

В Python реализация родительского модуля выбирается не динамически, а самим
программистом.

5. Новый модуль может интегрировать общее поведение нескольких модулей, которые
   различаются лишь деталями.

В Python этот принцип можно реализовать, например, множественным наследованием
или композицией классов внутри одного.


----------------------- TASK 6 -----------------------

1. Существуют ли ситуации, когда связи между модулями должны делаться публичными?

Так стоит делать для модулей, реализация которых требует прозрачности. Например:
- архитектура нейронной сети, в которой слои это отдельные модули
- ETL-приложения, где положение модулей в цепочке обработки данных зависит от
  интерфейсов других модулей в ней.


2. Какие метрики вы бы предложили для количественной оценки принципов организации
   модулей?

Для семейства модулей (классов), совместно решающих одну задачу:
- I - Количество зависимостей - число использованных классов в данном классе
- O - Количество зависимых модулей - число классов использующих данный класс
- C - "Коэффициент открытости-закрытости": С = O / (I + O). Чем ближе С к 1,
  тем класс более "закрытый"

Для модулей, решающих разные задачи одной предметной области (одного уровня
программы), устремить количество зависимостей к 0.


3. Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы
   вы оценили их модульность по этим метрикам?

1 из 6 классов был "закрытым" (С=1). Он был очень перегруженным как публичными,
так и условно скрытыми методами. Они, в остальных 5 дочерних классах,
переопределялись (override) в разных комбинациях. В общем, принципы
открытости-закрытости и повторного использования нарушались повсеместно,
что быстро похоронило программу.

"""
